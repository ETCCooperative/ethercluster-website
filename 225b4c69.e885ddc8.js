(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{64:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return b}));var a=n(2),r=n(6),o=(n(0),n(87)),l={id:"doc3",title:"Build your first Ethercluster"},c={unversionedId:"doc3",id:"doc3",isDocsHomePage:!1,title:"Build your first Ethercluster",description:"This guide will help you build your own Ethereum Classic API service using Ethercluster. This guide currently features Ethercluster deployment on Google Cloud Platform.",source:"@site/docs\\doc3.md",slug:"/doc3",permalink:"/ethercluster-website/docs/doc3",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/doc3.md",version:"current",sidebar:"someSidebar",previous:{title:"Core Concepts",permalink:"/ethercluster-website/docs/doc2"},next:{title:"API",permalink:"/ethercluster-website/docs/"}},i=[{value:"Step 01 - Setup Google Cloud",id:"step-01---setup-google-cloud",children:[]},{value:"Step 02 - Install Terraform",id:"step-02---install-terraform",children:[]},{value:"Step 03 - Create a Terraform configuration for GKE",id:"step-03---create-a-terraform-configuration-for-gke",children:[]},{value:"Understanding our Terraform configuration file",id:"understanding-our-terraform-configuration-file",children:[{value:"GKE",id:"gke",children:[]}]},{value:"Step 04 - Terraform <code>Plan</code> and <code>Apply</code> infrastructure",id:"step-04---terraform-plan-and-apply-infrastructure",children:[]},{value:"Step 05 - Final cluster setup",id:"step-05---final-cluster-setup",children:[{value:"Namespace",id:"namespace",children:[]},{value:"Volume",id:"volume",children:[]},{value:"Service",id:"service",children:[]},{value:"Deployment",id:"deployment",children:[]},{value:"Confirm node is running",id:"confirm-node-is-running",children:[]}]},{value:"Scaling Pods",id:"scaling-pods",children:[]},{value:"SSL Configuration",id:"ssl-configuration",children:[{value:"Secrets",id:"secrets",children:[]},{value:"Ingress",id:"ingress",children:[]}]}],s={rightToc:i};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This guide will help you build your own Ethereum Classic API service using Ethercluster. This guide currently features Ethercluster deployment on Google Cloud Platform."),Object(o.b)("h2",{id:"step-01---setup-google-cloud"},"Step 01 - Setup Google Cloud"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Signup for a ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.google.com/"}),"Google Cloud")," account and ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://console.cloud.google.com/projectcreate"}),"create a new project"),". You can conveniently name your project, ",Object(o.b)("inlineCode",{parentName:"li"},"ethercluster"),".")),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"https://user-images.githubusercontent.com/10556209/96285459-9c85ce00-0fa4-11eb-9407-277b6ee700ca.png",alt:null}))),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Setup ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://cloud.google.com/billing/docs/how-to/modify-project"}),"billing")," if you're going to pursue making your Ethercluster. ")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Enable ",Object(o.b)("strong",{parentName:"p"},"Compute Engine API"),", ",Object(o.b)("strong",{parentName:"p"},"Cloud Shell API"),", and ",Object(o.b)("strong",{parentName:"p"},"Kubernetes Engine API")," which can be found in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://console.cloud.google.com/apis?_ga=2.172155431.56694028.1602866660-1600774775.1602866660"}),"Marketplace"),". For example: "))),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"https://user-images.githubusercontent.com/10556209/96285814-0e5e1780-0fa5-11eb-95ff-a3a3d571bf0a.png",alt:null}))),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://cloud.google.com/docs/authentication/getting-started"}),"Setup Credentials")," which will generate a JSON file for you to download. This will be used to easily authenticate into Google Cloud from your local terminal.")),Object(o.b)("h2",{id:"step-02---install-terraform"},"Step 02 - Install Terraform"),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.terraform.io/"}),"Terraform")," is infra-as-code to allow you to provision your cloud infrastructure in a way that's clear and easy to roll-back and version control."),Object(o.b)("p",null,"This allows any changes you make to your cloud architecture to be reflected in code and saved, so that any new changes you add can be tracked and debugged."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.terraform.io/downloads.html"}),"Download, unpack, and install Terraform")," via release binary for your operating system ",Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.terraform.io/downloads.html"}),"https://www.terraform.io/downloads.html"),".")),Object(o.b)("p",null,"Downloading binary on Linux:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"wget https://releases.hashicorp.com/terraform/0.13.4/terraform_0.13.4_linux_amd64.zip\n")),Object(o.b)("p",null,"Unpack files:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"unzip terraform_0.13.4_linux_amd64.zip\n")),Object(o.b)("p",null,"At this point the executable ",Object(o.b)("inlineCode",{parentName:"p"},"terraform")," binary can be run. However, you may want to move it in a more appropriate location and add to your PATH."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"sudo mv terraform /bin/\n")),Object(o.b)("p",null,"or move anywhere else and export to PATH"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"mv terraform /$HOME\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),'export PATH="$PATH:/$HOME/terraform"\n')),Object(o.b)("p",null,"Run terraform from a terminal"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"terraform\n")),Object(o.b)("h2",{id:"step-03---create-a-terraform-configuration-for-gke"},"Step 03 - Create a Terraform configuration for GKE"),Object(o.b)("p",null,"Create directory for your Terraform project and change directory into it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"mkdir Ethercloud && cd Ethercloud\n")),Object(o.b)("p",null,"Initialize a new Terraform project:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"terraform init\n")),Object(o.b)("p",null,"Terraform will return the following since there's no existing Terraform config files."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"Terraform initialized in an empty directory!\n\nThe directory has no Terraform configuration files. You may begin working\nwith Terraform immediately by creating Terraform configuration files.\n")),Object(o.b)("p",null,"Now, create a new Terraform configuration file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"touch ethercloud.tf\n")),Object(o.b)("p",null,"Using your preferred editor, we'll have to specify our Ethercluster infrastructure in ",Object(o.b)("inlineCode",{parentName:"p"},"ethercloud.tf")," like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'provider "google" {\n    project = "ethercluster"\n    region = "us-central1"       \n    zone = "us-central1-c"\n}\n\nresource "google_container_cluster" "primary" {\n    name = "ether-cluster"\n    \n    remove_default_node_pool = true\n    initial_node_count = 1\n\n    master_auth {\n        username = ""\n        password = ""\n    }\n}\n\nresource "google_container_node_pool" "primary_preemptible_nodes" {\n    name = "my-node-pool"\n    cluster = "${google_container_cluster.primary.name}"\n    node_count = 3\n    \n    node_config {\n        preemptible = true\n        machine_type = "n1-standard-1"\n\n        metadata = {\n            disable-legacy-endpoints = "true"\n        }\n\n        oauth_scopes = [\n            "https://www.googleapis.com/auth/logging.write",\n            "https://www.googleapis.com/auth/monitoring",\n        ]\n    }\n}\n\noutput "client_certificate" {\n    value = "${google_container_cluster.primary.master_auth.0.client_certificate}"\n}\n\noutput "client_key" {\n    value = "${google_container_cluster.primary.master_auth.0.client_key}"\n}\n\noutput "cluster_ca_certificate" {\n    value = "${google_container_cluster.primary.master_auth.0.cluster_ca_certificate}"\n}\n\nresource "google_compute_address" "ip_address" {\n    name = "ethercluster-address"\n}\n')),Object(o.b)("h2",{id:"understanding-our-terraform-configuration-file"},"Understanding our Terraform configuration file"),Object(o.b)("h4",{id:"provider"},"Provider"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tf"}),'provider "google" {\n    project = "ethercloud"\n    region = "us-central1"\n    zone = "us-central1-c"\n}\n')),Object(o.b)("p",null,"What we did here was specify provider as ",Object(o.b)("inlineCode",{parentName:"p"},"google"),", gave it a project name ",Object(o.b)("inlineCode",{parentName:"p"},"ethercloud"),", and then added the region ",Object(o.b)("inlineCode",{parentName:"p"},"us-central-1")," and the zone ",Object(o.b)("inlineCode",{parentName:"p"},"us-central1-c"),". You don't have to use the same names and regions, but this will be what I use for the purpose of this guide."),Object(o.b)("h3",{id:"gke"},"GKE"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'resource "google_container_cluster" "primary" {\n    name = "ethercluster"\n\n    remove_default_node_pool = true\n    initial_node_count = 1\n\n    master_auth {\n        username = ""\n        password = ""\n    }\n}\n')),Object(o.b)("p",null,"This specifies that we want a GKE cluster we will call ",Object(o.b)("inlineCode",{parentName:"p"},"primary"),". We also specify the cluster name as ",Object(o.b)("inlineCode",{parentName:"p"},"ethercluster")," We add an initial node count of ",Object(o.b)("inlineCode",{parentName:"p"},"1"),", but we can't specify our own Kubernetes node pool first, so we use the initial node count and then we delete it. We have our ",Object(o.b)("inlineCode",{parentName:"p"},"master_auth")," set to empty because we don't want to use any custom auth."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'resource "google_container_node_pool" "primary_preemptible_nodes" {\n    name = "my-node-pool"\n    cluster = "${google_container_cluster.primary.name}"\n    node_count = 3\n\n    node_config {\n        preemptible = true\n        machine_type = "n1-standard-1"\n\n        metadata = {\n            disable-legacy-endpoints = "true"\n        }\n\n        oauth_scopes = [\n            "https://www.googleapis.com/auth/logging.write",\n            "https://www.googleapis.com/auth/monitoring",\n        ]\n    }\n}\n')),Object(o.b)("p",null,"Here we are basically specifying the node pool with 3 nodes. Three nodes means three Google Compute Engine instances where we will be hosting out Kubernetes cluster. We also specify the type of instance to be ",Object(o.b)("inlineCode",{parentName:"p"},"n1-standard-1"),"."),Object(o.b)("p",null,"For more information on this setup, checkout the guide from Terraform ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.terraform.io/docs/providers/google/r/container_cluster.html"}),"here"),"."),Object(o.b)("p",null,"Moving forward, we want to add the Cluster certificate and a static IP address in case you chose to expose your RPC endpoint publicly over SSL. It'll be easier to assign it to a static IP address you created on GKE so it doesn't change addresses every time you modify it."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'output "client_certificate" {\n    value = "${google_container_cluster.primary.master_auth.0.client_certificate}"\n}\n\noutput "client_key" {\n    value = "${google_container_cluster.primary.master_auth.0.client_key}"\n}\n\noutput "cluster_ca_certificate" {\n    value = "${google_container_cluster.primary.master_auth.0.cluster_ca_certificate}"\n}\n\nresource "google_compute_address" "ip_address" {\n    name = "ethercluster-address"\n}\n')),Object(o.b)("p",null,"Here, we basically specify the client key and certificate, as well as cluster certificate and ip_address. We will call this address ",Object(o.b)("inlineCode",{parentName:"p"},"ethercluster-address"),"."),Object(o.b)("p",null,"Great, we finally have the entire code we need to get started. Let's start terraforming!"),Object(o.b)("h2",{id:"step-04---terraform-plan-and-apply-infrastructure"},"Step 04 - Terraform ",Object(o.b)("inlineCode",{parentName:"h2"},"Plan")," and ",Object(o.b)("inlineCode",{parentName:"h2"},"Apply")," infrastructure"),Object(o.b)("p",null,"Now that your infrastructure is defined in your terraform configuration file, it's time to ",Object(o.b)("inlineCode",{parentName:"p"},"terraform plan")," & ",Object(o.b)("inlineCode",{parentName:"p"},"terraform apply"),"."),Object(o.b)("p",null,"Terraform plan allows you to see what changes Terraform will do to your file without making the changes. It also is helpful for catching bugs."),Object(o.b)("p",null,"Run ",Object(o.b)("inlineCode",{parentName:"p"},"terraform plan"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"terraform plan\n")),Object(o.b)("p",null,"Terraform will analyse your code and return an output like the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'Refreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  # google_compute_address.ip_address will be created\n  + resource "google_compute_address" "ip_address" {\n      + address_type       = "EXTERNAL"\n      + name               = "ethercluster-address"\n      *\n    }\n\n  # google_container_cluster.primary will be created\n  + resource "google_container_cluster" "primary" {\n      + name                        = "ether-cluster"\n      + network                     = "default"\n      *\n    }\n\n  # google_container_node_pool.primary_preemptible_nodes will be created\n  + resource "google_container_node_pool" "primary_preemptible_nodes" {\n      + cluster             = "ether-cluster"\n      + id                  = (known after apply)\n      *\n      + management {\n          * \n        }\n\n      + node_config {\n            *\n        }\n    }\n\nPlan: 3 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n')),Object(o.b)("p",null,"Note, this isn't the exact output, it'll have a lot more data in it with keys, but the values will say ",Object(o.b)("inlineCode",{parentName:"p"},"(known after apply)"),". This tells us that Terraform won't have the exact values for the configuration of our cloud for most of the keys until after we actually create our architecture on Google Cloud."),Object(o.b)("p",null,"To apply the configuration on Google Cloud, simply run ",Object(o.b)("inlineCode",{parentName:"p"},"terraform apply"),"."),Object(o.b)("p",null,"Run Terraform apply:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"terraform apply\n")),Object(o.b)("p",null,"Now, since you already have your project json file from Google Cloud for authing added to your PATH in previous sections, Terraform can use it to deploy your cloud architecture for you. It'll go through the same output you saw in plan but with an execution plan and then start creating your instances. It'll take a little time to create, so go have a coffee break while you wait."),Object(o.b)("p",null,"The output will look something like the following."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"https://user-images.githubusercontent.com/10556209/96288555-36e81080-0fa9-11eb-8afb-0ff68611cd23.gif",alt:"terraform-apply"}))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n*\n*\n*\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n")),Object(o.b)("p",null,"Terraform has just created your infrastructure architecture on Google Cloud. Now it's time to SSH into Google Cloud Shell."),Object(o.b)("h2",{id:"step-05---final-cluster-setup"},"Step 05 - Final cluster setup"),Object(o.b)("p",null,"Now, at this point we have our Ethercluster node infrastructure deployed which is a fully functioning kubernetes cluster on Google Cloud. Running a node requires storage, the protocol providing client, and our desired networking for access the API."),Object(o.b)("h3",{id:"namespace"},"Namespace"),Object(o.b)("p",null,"Namespaces in Kubernetes allow us to assign a name for specific projects we are working on inside Kubernetes. It's useful if you want to organize your cluster between ",Object(o.b)("inlineCode",{parentName:"p"},"dev")," and ",Object(o.b)("inlineCode",{parentName:"p"},"prod")," namespaces for example."),Object(o.b)("p",null,"Here, we will just be using it for ",Object(o.b)("inlineCode",{parentName:"p"},"ethercluster")," to make it easier to see everything."),Object(o.b)("p",null,"To create a namespace, I'll be writing up a YAMl config file for Kubernetes."),Object(o.b)("p",null,"Each Kubernetes manifest file has three things:"),Object(o.b)("p",null,"apiVersion (to specify which API to use)\nkind (to determine what Kubernetes component the file is)\nmetadata (extra information about the manifest)"),Object(o.b)("p",null,"We also have a ",Object(o.b)("inlineCode",{parentName:"p"},"spec")," section to specify how we want the manifest behaves, which we will see when we build our cluster."),Object(o.b)("p",null,"Picking up from where we left off in Google Cloud Shell page, let's see if ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl")," is running. ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl")," is a command line application that uses the Kubernetes API to interact with your cluster."),Object(o.b)("p",null,"Connect to cluster from inside Google Cloud Shell:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"gcloud container clusters get-credentials ethercloud --zone us-central1-c --project ethercloud\n")),Object(o.b)("p",null,"Check if ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl")," is working:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl\n")),Object(o.b)("p",null,"The output would be similar to:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),'The output should look something like this:\n\nkubectl controls the Kubernetes cluster manager.\n\nFind more information at: https://kubernetes.io/docs/reference/kubectl/overview/\n\n*\n*\n*\n\nUsage:\n  kubectl [flags] [options]\n\nUse "kubectl <command> --help" for more information about a given command.\nUse "kubectl options" for a list of global command-line options (applies to all commands).\n')),Object(o.b)("p",null,"Now, let's define namespace in the Namespace manifect file. You can use ",Object(o.b)("inlineCode",{parentName:"p"},"vim")," or your preferred editor:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"vim ethercluster-namespace.yml\n")),Object(o.b)("p",null,"Add the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"apiVersion: v1\nkind: Namespace\nmetadata:\n    name: ethercluster \n    labels:\n        name: ethercluster \n")),Object(o.b)("p",null,"This specifies that our manifest is ",Object(o.b)("inlineCode",{parentName:"p"},"kind")," of ",Object(o.b)("inlineCode",{parentName:"p"},"Namespace"),", with a name of ",Object(o.b)("inlineCode",{parentName:"p"},"ethercluster"),"."),Object(o.b)("p",null,"Now that there is a manifest for Namespace, it has to be applied like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl apply -f ethercluster-namespace.yml\n")),Object(o.b)("p",null,"Output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"namespace/ethercluster created\n")),Object(o.b)("h3",{id:"volume"},"Volume"),Object(o.b)("p",null,"We will need to specify a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/storage/storage-classes/"}),"StorageClass")," for our Deployment volume. Here, we will use SSD since it's best for syncing clients."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"vim classic-storage-class.yml\n")),Object(o.b)("p",null,"Add the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),"kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: classic-ssd\n  namespace: ethercluster\nprovisioner: kubernetes.io/gce-pd\nparameters:\n  type: pd-ssd\n  zones: us-central1-c\nreclaimPolicy: Retain\n")),Object(o.b)("p",null,"Notice how we specified the provisioner to be ",Object(o.b)("inlineCode",{parentName:"p"},"gce-pd"),". It's to specify the Cloud Provider type of disk we want. We then specify it to be a persistent disk SSD ",Object(o.b)("inlineCode",{parentName:"p"},"pd-ssd")," and the zone is ",Object(o.b)("inlineCode",{parentName:"p"},"us-central1-c")," which is the same one we specified in Terraform, which is where our GKE cluster was created."),Object(o.b)("p",null,"Let's create the StorageClass via:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl apply -f classic-storage-class.yml\n")),Object(o.b)("p",null,"This will create the StorageClass in Google Cloud which we will use when doing a Deployment later."),Object(o.b)("h3",{id:"service"},"Service"),Object(o.b)("p",null,"In Service, we will need to specify the ports we are interested in obtaining from our node. For the purpose of a public RPC endpoint, we will need port 8545 which is the default RPC port. If you need something more custom, like WebSockets, then port 8546 is the one you want. Here, we will only go over 8545. We add 8080 for default and 443 for SSL."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"vim classic-service.yml\n")),Object(o.b)("p",null,"Add the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: classic\n  name: classic\n  namespace: ethercluster\n  annotations:\n    cloud.google.com/app-protocols: \'{"my-https-port":"HTTPS","my-http-port":"HTTP"}\'\nspec:\n  selector:\n    app: classic\n  ports:\n  - name: default\n    protocol: TCP\n    port: 80\n    targetPort: 80\n  - name: rpc-endpoint\n    port: 8545\n    protocol: TCP\n    targetPort: 8545\n  - name: https\n    port: 443\n    protocol: TCP\n    targetPort: 443\n  type: LoadBalancer\n  sessionAffinity: ClientIP\n')),Object(o.b)("p",null,"If you notice, we specify the ",Object(o.b)("inlineCode",{parentName:"p"},"kind")," to be Service here. We call the service ",Object(o.b)("inlineCode",{parentName:"p"},"classic")," which will allow it to auto-discover the deployment after with the same name."),Object(o.b)("p",null,"Notice how we have ",Object(o.b)("inlineCode",{parentName:"p"},"port")," and ",Object(o.b)("inlineCode",{parentName:"p"},"targetPort")," specified. It tells the Service we want to this Service's port 8545 to route to the container's port 8545."),Object(o.b)("p",null,"We specify the type to be ",Object(o.b)("inlineCode",{parentName:"p"},"LoadBalancer")," to expose it and allow for selecting between the different nodes we will create with Parity. We also add a sessionAffinity so that if you connect to a node assigned by the load balancer, the next time you connect to it, load balancer will reconnect you to the same node."),Object(o.b)("p",null,"Create the service:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl apply -f classic-service.yml\n")),Object(o.b)("p",null,"Now, get all components of your cluster:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl get all -n ethercluster\n")),Object(o.b)("p",null,"Example output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME                        TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                                       AGE\nservice/classic             LoadBalancer   10.00.00.00   <pending>      8080:30003/TCP,8545:30002/TCP,443:30001/TCP   1m\n")),Object(o.b)("p",null,"The external-ip is ",Object(o.b)("inlineCode",{parentName:"p"},"<pending>")," because Kubernetes is creating an endpoint to expose which may take a few minutes. While this is running we can move onto deploying our blockchain API service."),Object(o.b)("h3",{id:"deployment"},"Deployment"),Object(o.b)("p",null,"For the rest of this exercise we'll be going over the code found in this ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/ethereum-classic-cooperative/ethercluster"}),"repository")," which contains example manifest files. Before running our deployment and running a node we need to figure out what arguments we need for our Docker container image."),Object(o.b)("p",null,"We will use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://hub.docker.com/r/hyperledger/besu/tags"}),"Hypereledger Besu")," has our protocol providing client. Hyperledger Besu is an enterprise Ethereum client that can be used for Ethereum, Ethereum Classic, and related test networks."),Object(o.b)("p",null,"If you're familiar with Docker, running a Besu docker container could be done with the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"docker run -p 8545:8545 -p 13001:30303 hyperledger/besu:latest --rpc-http-enabled --network=CLASSIC\n")),Object(o.b)("p",null,"If you go to ",Object(o.b)("inlineCode",{parentName:"p"},"deployments/classic/classic-besu-stateful-set.yml"),", you'll see that the file has the ",Object(o.b)("inlineCode",{parentName:"p"},"kind")," value of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/"}),"StatefulSet"),". This is important since it specifies we want a stateful application that guarantees ordering and uniqueness across any rescheduling. Imagine we didn't use a statefulset here. If we deploy our container to Kubernetes, Besu begins syncing the chain from the beginning. Kubernetes can then choose to restart Pods at intervals to ensure updates. What happens in this situation is that the restart will also cause Besu to resync from the beginning, which isn't what we desire. It's why StatefulSet is the desired Deployment here."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"apiVersion: apps/v1beta1\nkind: StatefulSet\nmetadata:\n  name: classic\n  namespace: ethercluster\n  labels:\n    app: classic\n")),Object(o.b)("p",null,"This is the beginning of our StatefulSet deployment file. It specifies the correct namespace for Ethercluster, names our Deployment ",Object(o.b)("inlineCode",{parentName:"p"},"classic")," in order to be able to identify what network it is, and points the ",Object(o.b)("inlineCode",{parentName:"p"},"kind")," to StatefulSet."),Object(o.b)("p",null,"This isn't the only contents of the file, we will go on and define the ",Object(o.b)("inlineCode",{parentName:"p"},"specs"),"."),Object(o.b)("p",null,"In the specs, you'll notice we have the ",Object(o.b)("inlineCode",{parentName:"p"},"replicas")," to be 3. This means we will be running 3 Parity nodes, which we will LoadBalance. In containers section, we specify the image ",Object(o.b)("inlineCode",{parentName:"p"},"besu")," from Besu's Dockerhub endpoint."),Object(o.b)("p",null,"We pass in the values to that containers such as ",Object(o.b)("inlineCode",{parentName:"p"},"chain=classic"),". This specifies that we want the Ethereum Classic chain to be our default network to run. This is how Kubernetes can specify the arguments for the container like Docker does in the previous example."),Object(o.b)("p",null,"We also specify we want the ports 8545 since we want to expose the RPC. We have some readinessProbe and livenessProbe in order to do health checks on the Probe. It happens by doing an HTTP GET request on port 8545 of the container on the endpoint ",Object(o.b)("inlineCode",{parentName:"p"},"/api/health"),", which checks if the Parity node is fully synced or not. If it's not synced up yet, it returns a 503, otherwise it will return a 200, thus passing the health check."),Object(o.b)("p",null,"We also specify a ",Object(o.b)("inlineCode",{parentName:"p"},"volumeClaimTemplates")," for this Deployment of 50 GB, which is what will be needed to run a full ETC node. If you want to instead run an ETH node, you'll need to adjust the value appropriately (300 GB to stay on the safe side)."),Object(o.b)("p",null,"Now, we will instantiate the deployment:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl apply -f deployments/classic/classic-besu-stateful-set.yml\n")),Object(o.b)("p",null,"See the deployment in action:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl get all -n ethercluster\n")),Object(o.b)("p",null,"Example output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME                                     READY   STATUS    RESTARTS   AGE\npod/classic-0                            2/2     Running   0          1m\npod/classic-1                            2/2     Running   0          1m\npod/classic-2                            2/2     Running   0          1m\n\nNAME                        TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                                       AGE\nservice/classic             LoadBalancer   10.00.00.00     109.01.01.01      8080:30003/TCP,8545:30002/TCP,443:30001/TCP   1m\n\nNAME                       READY   AGE\nstatefulset.apps/classic   3/3     1m\n")),Object(o.b)("p",null,"Note that the age shown above might not be exact to what you get since it's still creating each Pod 1 by 1. Why do we have three pods? It's because we specified our replica to be 3 in our deployment file."),Object(o.b)("p",null,"Each pod is created by the Statefulset, where it's mounted to a volume from ",Object(o.b)("inlineCode",{parentName:"p"},"classic-ssd")," that we instantiated before, and then each image of the containers are pulled and instantiated, and begin running, before the next pod is created."),Object(o.b)("p",null,"Inspect a pod individually:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl describe pod classic-0 -n ethercluster\n")),Object(o.b)("p",null,"View logs:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl logs classic-0 besu -n ethercluster\n")),Object(o.b)("p",null,"Woohoo! Now you have a fully functioning Ethereum Classic node with built on a kubernetes cluster."),Object(o.b)("h3",{id:"confirm-node-is-running"},"Confirm node is running"),Object(o.b)("p",null,"Use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://curl.haxx.se/"}),"cURL")," to call ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://besu.hyperledger.org/en/stable/Reference/API-Methods/"}),"JSON-RPC API methods"),"to confirm the node is running."),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"replace ",Object(o.b)("inlineCode",{parentName:"em"},"IP")," with your ",Object(o.b)("inlineCode",{parentName:"em"},"External IP"),"  from ",Object(o.b)("inlineCode",{parentName:"em"},"kubectl get services classic -n ethercluster"))),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"eth_chainId")," returns the chain ID of the network:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'curl -X POST --data \'{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}\' localhost:8545\n')),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"eth_syncing")," returns the starting, current, and highest block."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'curl -X POST --data \'{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}\' localhost:8545\n')),Object(o.b)("p",null,"After connecting to mainnet ",Object(o.b)("inlineCode",{parentName:"p"},"eth_syncing")," will return something similar to:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "jsonrpc" : "2.0",\n  "id" : 1,\n  "result" : {\n    "startingBlock" : "0x0",\n    "currentBlock" : "0x2d0",\n    "highestBlock" : "0x66c0"\n  }\n}\n')),Object(o.b)("h2",{id:"scaling-pods"},"Scaling Pods"),Object(o.b)("p",null,"Depending on your network traffic you may need to scale you may need to scale your cluster up or down in Kubernetes with one command:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubernetes scale statefulset classic -n ethercluster --replicas=4\n")),Object(o.b)("p",null,"This will increase replicas to 4 or decrease replicas to however many you desire."),Object(o.b)("p",null,"See it being created:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubernetes get all -n ethercluster\n")),Object(o.b)("p",null,"Example output:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME                                     READY   STATUS    RESTARTS   AGE\npod/classic-0                            2/2     Running   0          10m\npod/classic-1                            2/2     Running   0          10m\npod/classic-2                            2/2     Running   0          10m\npod/classic-3                            2/2     Running   0          1m\n\nNAME                        TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                                       AGE\nservice/classic             LoadBalancer   10.00.00.00     109.01.01.01      8080:30003/TCP,8545:30002/TCP,443:30001/TCP   10m\n\nNAME                       READY   AGE\nstatefulset.apps/classic   3/3     10m\n")),Object(o.b)("p",null,"Notice you now have a ",Object(o.b)("inlineCode",{parentName:"p"},"classic-3")," pod being created and beginning to sync. You can do the same thing to scale it back to 3 by changing the previous command from 4 replicas to 3. Also, GKE does offer auto-scaling for you if needed, but that'll affect your billing if you don't monitor it consistently."),Object(o.b)("p",null,"In the next section, we will go over securing your endpoint with SSL when using it publicly. It's not really needed if you want to use RPC only internally within your own infrastructure."),Object(o.b)("h2",{id:"ssl-configuration"},"SSL Configuration"),Object(o.b)("p",null,"To setup SSL configuration you need:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"a domain name"),Object(o.b)("li",{parentName:"ul"},"SSL certificate for the domain name")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Ethercluster.com")," uses Namecheap and Namecheap has a guide on registering an SSL for you which will provide an:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"SSL Key ",Object(o.b)("inlineCode",{parentName:"li"},".key")),Object(o.b)("li",{parentName:"ul"},"SSL Certificate ",Object(o.b)("inlineCode",{parentName:"li"},".crt"))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"NOTE")," Setting up SSL for your Ethercluster is optional, but useful to expose your RPC publicly."),Object(o.b)("h3",{id:"secrets"},"Secrets"),Object(o.b)("p",null,"Now that we have our ",Object(o.b)("inlineCode",{parentName:"p"},"domain-com.key")," and ",Object(o.b)("inlineCode",{parentName:"p"},"domain-com.crt"),", we can create a Kubernetes secret for them so we can securely store it."),Object(o.b)("p",null,"If we have both files in a directory called ",Object(o.b)("inlineCode",{parentName:"p"},"config"),", then we can run the following command to instantiate them:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl tls tls-classic --key ./config/domain-com.key --cert ./config/domain-com.crt --namespace ethercluster \n")),Object(o.b)("h3",{id:"ingress"},"Ingress"),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"}),"Ingress")," allows us to route to different services to the outside via HTTP and HTTPS, as well as allow us to terminate TCP/SSL."),Object(o.b)("p",null,"We will need to create the ingress manifest file then instantiate it. After that, we need to configure the Health Checks in Google Cloud."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"vim ingress.yml\n")),Object(o.b)("p",null,"And input the following contents in ingress.yml:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yml"}),'apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n    name: ingress-ethercluster\n    namespace: ethercluster\n    annotations:\n        kubernetes.io/ingress.global-static-ip-name: ethercluster-address\n        kubernetes.io/ingress.allow-http: "false"\n        kubernetes.io/ingress.class: "gce"\nspec:\n    tls:\n      - hosts:\n        - www.domain.com\n        secretName: tls-classic\n    backend:\n      serviceName: classic \n      servicePort: 8545\n    rules:\n    - host: www.domain.com\n      http:\n        paths:\n        - path: /\n          backend:\n            serviceName: classic\n            servicePort: 8545\n')),Object(o.b)("p",null,"This specifies that we're creating an ingress that points to ",Object(o.b)("inlineCode",{parentName:"p"},"ethercluster-address")," (the static IP created in Terraform). It also assigns the host to the domains.com we added and provides "),Object(o.b)("p",null,"It also assigns the host to the domain.com we added and provides the secretName as ",Object(o.b)("inlineCode",{parentName:"p"},"tls-classic")," as we created before. It wires to the backend to the serviceName ",Object(o.b)("inlineCode",{parentName:"p"},"classic")," at port 8545."),Object(o.b)("p",null,"Instantiate the ingress:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl apply -f ingress.yml\n")),Object(o.b)("p",null,"Monitor progression:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl describe ingress ingress-ethercluster -n ethercluster\n")),Object(o.b)("p",null,"While you monitor it, you need to head over to Google Cloud to set up the Health Checks. Reason is, it won't be exposed publicly if the health checks aren't passed on Google Cloud, and they're not yet sure how to check the health status of Parity."),Object(o.b)("p",null,"We do that by going over to Google Cloud, and then to Kubernetes Engine section on the left, and then click on Services as shown below:"),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"https://user-images.githubusercontent.com/10556209/97757447-b954f200-1aca-11eb-9a22-393b4ab3dd71.png",alt:null}))),Object(o.b)("p",null,"We click on the Ingress we created earlier here, and then try to determine the port number for your classic service. It's the port number assigned by Kubernetes. You can find it by running the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell"}),"kubectl get service classic -n ethercluster\n")),Object(o.b)("p",null,"It'll return what we saw earlier:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME                        TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                                       AGE\nservice/classic             LoadBalancer   10.00.00.00   <pending>      8080:30003/TCP,8545:30002/TCP,443:30001/TCP   1m\n")),Object(o.b)("p",null,"If you notice under ",Object(o.b)("inlineCode",{parentName:"p"},"PORT(S)"),", you'll see the port ",Object(o.b)("inlineCode",{parentName:"p"},"8545:30002"),". The 30002 is the one assigned by Kubernetes for the abstracted 8545. That's the port you'll need to look for under the Ingress section, as shown below: list-ingress"),Object(o.b)("p",null,"Click on the appropriate one, which will lead you to its page."),Object(o.b)("p",null,"Scroll down until you find the health check section. It has a link under it that you must click as well."),Object(o.b)("p",null,"Now, you're taken to the Health Check page."),Object(o.b)("p",null,"It checks Parity's 8545 port at actual port 30002. But it does the health check on this endpoint ",Object(o.b)("inlineCode",{parentName:"p"},"/")," Parity health checks happen at ",Object(o.b)("inlineCode",{parentName:"p"},"/api/health"),"."),Object(o.b)("p",null,"Configure it accordingly as shown below, then save it."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"https://user-images.githubusercontent.com/10556209/97757625-1e104c80-1acb-11eb-9af3-926dd9554312.png",alt:null}))),Object(o.b)("p",null,"Now, wait about 10-15 minutes for the health checks to pass. You should be able to now use your RPC endpoint over SSL."),Object(o.b)("p",null,"If you have any issues, you can always use ",Object(o.b)("inlineCode",{parentName:"p"},"kubectl describe")," to debug your ingress."),Object(o.b)("p",null,"I hope you enjoyed this guide and the cool tools given to us by the Cloud, Kubernetes and Terraform."))}b.isMDXComponent=!0}}]);